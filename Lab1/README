Diana Pham 203795717

This is a skeleton for CS 111 Lab 1.

Replace this README file with notes on your implementation.
Mentions any special features or limitations.

Limitations:
	Simple command length limited to 1024 characters as implementation relies on a buffer of that size. Exceeding limit causes a segfault.   

multi-pipes
void
execute_pipe_command(command_t *c)
{
    command_t command = *c;
    pid_t pid = fork();
    if(pid > 0) {
        int status;
        while(waitpid(pid, &status, 0) < 0)
            continue;
        if(!WIFEXITED(status))
            error(1, errno, "Child exit error");
        command->status = WEXITSTATUS(status);
        return;
    } else if (pid == 0) {
        while(command->type == PIPE_COMMAND)
        {
            int fd[2]; pipe(fd);
            pid = fork();
            if(pid > 0) {
                close(fd[0]);
                dup2(fd[1], STDOUT_FILENO);
                char **args = command->u.command[1]->u.word;
                execvp(args[0], args);
            } else if (pid == 0) {
                close(fd[1]);
                dup2(fd[0], STDIN_FILENO);
                command = command->u.command[0];
                continue;
            } else {
                error(1, errno, "forking error");
            }
        }
        char **args = command->u.word;
        execvp(args[0], args);
    } else {
        error(1, errno, "forking error");
    }
}

one pipe
void
execute_pipe_command(command_t *c)
{
	command_t command = *c;
	pid_t pid = fork();
	if(pid > 0) {
		int status;
		while(waitpid(pid, &status, 0) < 0)
			continue;
		if(!WIFEXITED(status))
			error(1, errno, "Child exit error");
		command->status = WEXITSTATUS(status);
		return;
	} else if (pid == 0) {
		int fd[2]; pipe(fd);
		pid = fork();
	    if(pid > 0) {
	        close(fd[0]);
	        dup2(fd[1], STDOUT_FILENO);
	        char **args = command->u.command[0]->u.word;
	        execvp(args[0], args);
	    } else if (pid == 0) {
	        close(fd[1]);
	        dup2(fd[0], STDIN_FILENO);
	        char **args = command->u.command[1]->u.word;
	        execvp(args[0], args);
	    }
	} else {
		error(1, errno, "forking error");
	}
}